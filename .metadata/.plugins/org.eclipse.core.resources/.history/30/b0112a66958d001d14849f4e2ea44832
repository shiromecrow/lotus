/*
 * PL_encoder.c
 *
 *  Created on: Jan 6, 2023
 *      Author: sf199
 */


#include "PL_encoder.h"
#include "spi.h"
#include <stdio.h>


static uint8_t set_flag = 0;



uint16_t encoder_read_byte_R(uint16_t ret)

{

	uint16_t val;
	uint16_t parity;

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_RESET); //cs = 0;

	ret = ret | 0x4000;//先頭から2つ目のbitを1に
	parity=0;
	for(int i=0;i<15;i++) parity += (ret >> i) & 1;
	ret = ret | ((parity % 2) << 15);

	HAL_SPI_Transmit(&hspi3, &ret, 1, 100);

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_SET); //cs = 1;

	for(int i=0;i<100;i++){}

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_RESET); //cs = 1;

	val=0xC000;
	HAL_SPI_Receive(&hspi3, &val, 1, 100);

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_SET); //cs = 1;

	return val;

}

void encoder_write_byte_R(uint16_t ret, uint16_t val)

{

	uint16_t parity;

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_RESET); //cs = 0;

	ret = ret & 0xBFFF;//先頭から2つ目のbitを1に
	parity=0;
	for(int i=0;i<15;i++) parity += (ret >> i) & 1;
	ret = ret | ((parity % 2) << 15);

	HAL_SPI_Transmit(&hspi3, &ret, 1, 100);

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_SET); //cs = 1;

	for(int i=0;i<100;i++){}

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_RESET); //cs = 1;

	val = val & 0xBFFF;//先頭から2つ目のbitを0に
	parity=0;
	for(int i=0;i<15;i++) parity += (val >> i) & 1;
	val = val | ((parity % 2) << 15);

	HAL_SPI_Transmit(&hspi3, &val, 1, 100);

	HAL_GPIO_WritePin( ENCODER_R_CS_GPIO_Port, ENCODER_R_CS_Pin, GPIO_PIN_SET); //cs = 1;

}




uint16_t encoder_read_byte_L(uint16_t ret)

{

	uint16_t val;
	uint16_t parity;

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_RESET); //cs = 0;

	ret = ret | 0x4000;//先頭から2つ目のbitを1に
	parity=0;
	for(int i=0;i<15;i++) parity += (ret >> i) & 1;
	ret = ret | ((parity % 2) << 15);

	HAL_SPI_Transmit(&hspi3, &ret, 1, 100);

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_SET); //cs = 1;

	for(int i=0;i<100;i++){}

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_RESET); //cs = 1;

	val=0xC000;
	HAL_SPI_Receive(&hspi3, &val, 1, 100);

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_SET); //cs = 1;

	return val;

}

void encoder_write_byte_L(uint16_t ret, uint16_t val)

{

	uint16_t parity;

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_RESET); //cs = 0;

	ret = ret & 0xBFFF;//先頭から2つ目のbitを1に
	parity=0;
	for(int i=0;i<15;i++) parity += (ret >> i) & 1;
	ret = ret | ((parity % 2) << 15);

	HAL_SPI_Transmit(&hspi3, &ret, 1, 100);

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_SET); //cs = 1;

	for(int i=0;i<100;i++){}

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_RESET); //cs = 1;

	val = val & 0xBFFF;//先頭から2つ目のbitを0に
	parity=0;
	for(int i=0;i<15;i++) parity += (val >> i) & 1;
	val = val | ((parity % 2) << 15);

	HAL_SPI_Transmit(&hspi3, &val, 1, 100);

	HAL_GPIO_WritePin( ENCODER_L_CS_GPIO_Port, ENCODER_L_CS_Pin, GPIO_PIN_SET); //cs = 1;

}

void pl_encoder_init(void)

{

	uint8_t who_am_i = 0;

// check WHO_AM_I (0x75)

	who_am_i = encoder_read_byte(0x75);

// who am i = 0x12

	printf("\r\nwho_am_i = 0x%x\r\n", who_am_i);

// recheck

	if (who_am_i != 0x98) {

		HAL_Delay(100);

		who_am_i = encoder_read_byte(0x75);

		if (who_am_i != 0x98) {

			while (1) {

				printf("encoder_error\r");

			}

		}

	}

// set pwr might

// PWR_MIGHT_1 0x6B

	encoder_write_byte(0x6B, 0x00);

	HAL_Delay(50);

// PWR_MIGHT_2 0x6C

	encoder_write_byte(0x6C, 0x00);

	HAL_Delay(50);

// set encoder config

// GYRO_CONFIG 0x1B

	encoder_write_byte(0x1B, 0x18); // use 2000 dps

	HAL_Delay(50);

// ACCEL_CONFIG 0x1C

	encoder_write_byte(0x1C, 0x18); // use pm 16g

	HAL_Delay(50);

	set_flag = 1;

}

float ICM20602_encoder_READ(uint8_t H_reg)

{

	int16_t data = (int16_t) (((uint8_t) encoder_read_byte(H_reg) << 8)
			| (uint8_t) encoder_read_byte(H_reg + 1));

	float omega = (float) (data / 16.4f);

	return omega;

}

float ICM20602_ACCEL_READ(uint8_t H_reg)

{

	int16_t data = (int16_t) (((uint8_t) encoder_read_byte(H_reg) << 8)
			| (uint8_t) encoder_read_byte(H_reg + 1));

	float accel = (float) (data / 2048.0f);

	return accel;

}


